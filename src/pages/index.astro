---
import Layout from '../layouts/Layout.astro';
import OrderCard from '../components/OrderCard.astro';
import OrderFilter from '../components/OrderFilter.astro';
import OrderStats from '../components/OrderStats.astro';
import { fetchOrders } from '../services/supabaseService';
import { normalizeOrder, type NormalizedOrder } from '../utils/orderAdapter';

// Obtener directamente las órdenes desde Supabase
let orders: NormalizedOrder[] = [];
try {
  // Obtener órdenes de Supabase y normalizarlas
  const supabaseOrders = await fetchOrders();
  orders = supabaseOrders.map(order => normalizeOrder(order));
} catch (error) {
  console.error("Error al obtener datos de Supabase:", error);
}

// Formatear para mostrar las órdenes que son más recientes primero
const sortedOrders = [...orders].sort((a, b) => 
  b.timestamp.getTime() - a.timestamp.getTime()
);
---

<Layout title="Dashboard de Comandas - Cocina">
  <div class="mb-6">
    <div class="flex items-center justify-between mb-6">
      <h2 class="text-2xl font-bold">Panel de Control de Comandas</h2>
      <a href="/crear" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
        + Nueva Comanda
      </a>
    </div>
    
    <!-- Componente de estadísticas -->
    <OrderStats orders={orders} />
    
    <!-- Componente de filtro -->
    <OrderFilter activeFilter="all" />
    
    <!-- Notificaciones -->
    <div id="notifications" class="my-4 hidden">
      <div class="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded flex justify-between">
        <span id="notification-text"></span>
        <button id="close-notification" class="text-green-700">
          <span>&times;</span>
        </button>
      </div>
    </div>
    
    <!-- Panel de comandas -->
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4" id="orders-container">
      {orders.length > 0 ? (
        sortedOrders.map(normalizedOrder => (
          <OrderCard 
            order={normalizedOrder} 
            onStatusChange={(id: string, status: 'pending' | 'preparing' | 'ready' | 'delivered') => {
              // Aquí emitiría un evento personalizado, pero como estamos en SSR,
              // se manejará desde el script cliente
            }} 
          />
        ))
      ) : (
        <div class="col-span-3 text-center py-10">
          <div class="flex flex-col items-center justify-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            <p class="text-gray-500 text-xl mb-2">Aún no hay comandas</p>
            <p class="text-gray-400">Las comandas aparecerán aquí cuando se realicen nuevos pedidos.</p>
            <a href="/crear" class="mt-4 px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors">
              Crear comanda de prueba
            </a>
          </div>
        </div>
      )}
    </div>
    
    <!-- Mensaje cuando no hay comandas que coincidan con el filtro -->
    <div id="no-orders" class="hidden text-center py-10">
      <div class="flex flex-col items-center justify-center">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
        </svg>
        <p class="text-gray-500 text-xl mb-2">No hay comandas que coincidan con el filtro</p>
        <p class="text-gray-400">Intente con un filtro diferente para ver más resultados.</p>
        <button id="clear-filters" class="mt-4 px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition-colors">
          Mostrar todas
        </button>
      </div>
    </div>
  </div>
</Layout>

<script>
  import type { NormalizedOrder } from '../utils/orderAdapter';
  import { supabase } from '../services/supabaseService';
  
  // Referencias a elementos DOM
  const ordersContainer = document.getElementById('orders-container');
  const noOrdersElement = document.getElementById('no-orders');
  const notificationElement = document.getElementById('notifications');
  const notificationTextElement = document.getElementById('notification-text');
  const closeNotificationButton = document.getElementById('close-notification');
  
  // Estado de la aplicación
  let currentFilter = 'all';
  let orders: NormalizedOrder[] = [];
  
  // Cargar órdenes iniciales
  async function loadOrders() {
    try {
      const response = await fetch('/api/orders');
      if (response.ok) {
        const rawOrders = await response.json();
        orders = rawOrders.map((order: any) => ({
          ...order,
          timestamp: new Date(order.timestamp) // Convertir string de fecha a objeto Date
        }));
        renderOrders();
      }
    } catch (error) {
      console.log('Error al cargar las órdenes:', error);
      showNotification('Error al cargar las órdenes. Intente nuevamente más tarde.', 'error');
    }
  }
  
  // Filtrar y renderizar órdenes
  function renderOrders() {
    if (!ordersContainer) return;
    
    let filteredOrders = [...orders];
    
    // Aplicar filtro
    if (currentFilter !== 'all') {
      filteredOrders = orders.filter(order => order.status === currentFilter);
    }
    
    // Ordenar por fecha (más recientes primero)
    filteredOrders.sort((a, b) => 
      b.timestamp.getTime() - a.timestamp.getTime()
    );
    
    // Determinar visibilidad de mensajes de "no hay órdenes"
    if (filteredOrders.length === 0) {
      // Si no hay órdenes en total, mostrar el mensaje de vacío
      if (orders.length === 0) {
        // No hacemos nada, ya que el mensaje está renderizado en SSR
        // y solo aseguramos que el mensaje de "no coinciden con el filtro" esté oculto
        if (noOrdersElement) {
          noOrdersElement.classList.add('hidden');
        }
      } else {
        // Si hay órdenes pero ninguna coincide con el filtro
        if (noOrdersElement) {
          noOrdersElement.classList.remove('hidden');
        }
      }
    } else {
      // Si hay órdenes filtradas, ocultamos el mensaje de "no hay coincidencias"
      if (noOrdersElement) {
        noOrdersElement.classList.add('hidden');
      }
      
      // Renderizar las órdenes
      // Recargamos la página para mostrar las nuevas órdenes
      // En una implementación más sofisticada, actualizaríamos el DOM directamente
      location.reload();
    }
    
    // Actualizar estadísticas
    updateStats(orders);
  }
  
  // Actualizar estado de una orden
  async function updateOrderStatus(orderId: string, newStatus: string) {
    try {
      const response = await fetch(`/api/orders/${orderId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ status: newStatus })
      });
      
      if (response.ok) {
        const updatedOrder = await response.json();
        showNotification(`Orden #${updatedOrder.displayId || orderId} actualizada a ${getStatusText(newStatus)}`);
        loadOrders(); // Recargar órdenes
      } else {
        throw new Error('Error actualizando orden');
      }
    } catch (error) {
      console.error('Error al actualizar el estado de la orden:', error);
      showNotification('Error al actualizar el estado de la orden', 'error');
    }
  }
  
  // Actualizar estadísticas en tiempo real
  function updateStats(currentOrders: NormalizedOrder[]) {
    const pendingCount = currentOrders.filter(o => o.status === 'pending').length;
    const preparingCount = currentOrders.filter(o => o.status === 'preparing').length;
    const readyCount = currentOrders.filter(o => o.status === 'ready').length;
    
    // Actualizar contadores en la UI cuando tengamos la implementación real
  }
  
  // Mostrar notificación
  function showNotification(message: string, type: 'success' | 'error' = 'success') {
    if (notificationElement && notificationTextElement) {
      notificationElement.classList.remove('hidden', 'bg-green-100', 'bg-red-100', 'border-green-400', 'border-red-400', 'text-green-700', 'text-red-700');
      
      if (type === 'success') {
        notificationElement.classList.add('bg-green-100', 'border-green-400', 'text-green-700');
      } else {
        notificationElement.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
      }
      
      notificationTextElement.textContent = message;
      notificationElement.classList.remove('hidden');
      
      // Auto ocultar después de 5 segundos
      setTimeout(() => {
        notificationElement?.classList.add('hidden');
      }, 5000);
    }
  }
  
  // Función auxiliar para obtener texto del estado
  function getStatusText(status: string): string {
    const statusMap: Record<string, string> = {
      'pending': 'Pendiente',
      'preparing': 'Preparando',
      'ready': 'Listo',
      'delivered': 'Entregado'
    };
    return statusMap[status] || status;
  }
  
  // Configurar suscripción en tiempo real
  function setupRealtimeSubscription() {
    // Suscripción a cambios en la tabla 'orders'
    supabase
      .channel('orders-changes')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'orders' }, handleOrderChange)
      .subscribe();
  }
  
  // Manejar cambios en tiempo real de órdenes
  function handleOrderChange(payload: any) {
    // Cuando se crea una nueva orden
    if (payload.eventType === 'INSERT') {
      showNotification('¡Nueva comanda recibida!');
      loadOrders(); // Recargar órdenes
    }
    
    // Cuando se actualiza una orden
    if (payload.eventType === 'UPDATE') {
      const updatedOrder = payload.new;
      showNotification(`Comanda #${updatedOrder.order_id} actualizada a ${getStatusText(updatedOrder.status)}`);
      loadOrders(); // Recargar órdenes
    }
    
    // Cuando se elimina una orden
    if (payload.eventType === 'DELETE') {
      loadOrders(); // Recargar órdenes
    }
  }

  // Event Listeners
  document.addEventListener('DOMContentLoaded', () => {
    // Manejar el cambio de filtro
    document.addEventListener('filterChanged', ((event: CustomEvent) => {
      currentFilter = event.detail.filter;
      renderOrders();
    }) as EventListener);
    
    // Manejar el cambio de estado de orden
    document.addEventListener('orderStatusChanged', ((event: CustomEvent) => {
      const { orderId, status } = event.detail;
      updateOrderStatus(orderId, status);
    }) as EventListener);
    
    // Limpiar filtros cuando se hace clic en "Mostrar todas"
    document.getElementById('clear-filters')?.addEventListener('click', () => {
      currentFilter = 'all';
      // Emitir evento para actualizar la UI de filtros
      document.dispatchEvent(new CustomEvent('filtersCleared'));
      renderOrders();
    });
    
    // Cerrar notificación
    closeNotificationButton?.addEventListener('click', () => {
      notificationElement?.classList.add('hidden');
    });
    
    // Iniciar carga de órdenes y suscripciones en tiempo real
    loadOrders();
    setupRealtimeSubscription();
  });
</script>
